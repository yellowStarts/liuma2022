# 第一篇：在 Docker 中重载 Go 服务器

- 原文地址：https://dev.to/jacobsngoodwin/full-stack-memory-app-01-setup-go-server-with-reload-in-docker-62n
- 作者：[Jacob Goodwin](https://dev.to/jacobsngoodwin)

## 项目概述
这篇文章是关于建立一个记忆应用程序的系列教程的开始。用于管理记忆对象(我们称之为“memthings”)的客户端应用程序将使用 `React/Typescript` 构建。管理这些“memthings”的后端应用程序的API将使用 `Node/Typescript` 构建。用户帐户和认证将由一个单独的应用程序管理，其UI内置在Vue，后端内置在Go。所有这些应用程序都将被设置为在 docker 容器中运行，并且将通过 `Traefik` 提供的路由“托管”在同一个测试域中。

下面是应用程序的概述，以及我们将构建的视频演示!今天，我们将从搭建左上角应用程序（Account API）开始，并使用 `Traefik` 将请求正确地路由到这个容器。

![](./images/01-01.png)

本篇视频地址：https://www.youtube.com/watch?v=00YqXu8U1zQ

源码地址：[Github](https://github.com/JacobSNGoodwin/memrizr)

## 创建目录
作为参考，目录结构将在本文结束时如下所示(除去 `readme.md` 的内容)。还有 `memrize.code-workspace` 也不是必要的。

![](./images/01-02.png)

要开始搭建应用程序，我们需要创建一个文件夹，其中将包含所有子项目以及应用程序范围的配置文件(.env、docker-compose.yml)。我们通过创建一个根 `memrizr` 文件夹来做到这一点(在创建应用程序时，巧妙地重新拼写是非常重要的)。我们还创建了一个 `account` 目录，我们将在其中编写Golang应用程序。
```
$ mkdir memrizr
$ cd memrizr
$ git init
$ mkdir account
```

## 添加 main.go 文件
现在，我们将进入 `account` 文件夹，初始化 go 模块，并添加 `gin`，这是一个用Golang编写的 Web 框架和 http 路由器。在运行以下命令时，请确保在初始化模块时将我的Github存储库的名称替换为您自己的名称。
```
$ cd account  
$ go mod init github.com/jacobsngoodwin/memrizr
$ go get -u github.com/gin-gonic/gin
```
现在我们将创建 `main.go` 文件, 文件中我们：
- 创建一个路由器来处理到不同路径的 http 请求。现在，我们创建了一个到 `/api/account` 的单一GET路由，以及它的处理函数。
- 接下来，我们创建一个标准的 Golang `http server` 服务器结构，应用我们刚刚创建的 `gin` 路由器。
- 最后，我们在一个go例程中运行服务器。您可以在代码中的链接中了解更多关于服务器安全关闭的信息。实际上，该代码创建了一个名为 `quit` 的通道，用于监听终止信号(如ctrl-c)。`<- quit` 行将阻塞后续代码，直到接收到终止信号，然后关闭服务器。

account/main.go
```
package main

import (
	"context"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
)

func main() {
	// 可以在这里插入其他的记录器，以进行结构化或分层的日志记录
	log.Println("Starting server...")

	router := gin.Default()

	router.GET("/api/account", func(ctx *gin.Context) {
		ctx.JSON(http.StatusOK, gin.H{
			"hello": "world",
		})
	})

	srv := &http.Server{
		Addr:    ":8080",
		Handler: router,
	}

	// 优雅的服务器关闭 - https://github.com/gin-gonic/examples/blob/master/graceful-shutdown/graceful-shutdown/server.go
	go func() {
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Failed to initialize server: %v\n", err)
		}
	}()

	log.Printf("Listening on port %v\n", srv.Addr)

	// 等待终止信号的通道
	quit := make(chan os.Signal)

	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

	// 这将阻塞，直到一个信号被传递到 quit 通道
	<-quit

	// 上下文用于通知服务器它有5秒钟的时间来完成当前正在处理的请求
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// 关闭服务器
	log.Println("Shutting down server...")
	if err := srv.Shutdown(ctx); err != nil {
		log.Fatalf("Server forced to shutdown: %v\n", err)
	}
}
```
现在不能通过在 `account` 文件夹中运行 `go run main.go`来测试。

## 设置 Docker
让我们在 `account` 目录中创建一个 `Dockerfile` (如所写)。这个Dockerfile有几个阶段。第一阶段，`builder`(构建器)，是我们下载并安装所有依赖项，然后构建应用程序二进制文件的地方。稍后，我们还将在docker组成的开发环境中使用这个`builder`来自动重新加载应用程序。我们将通过名为 `reflex` 的应用程序来实现这一点，我们在构建程序阶段下载了该应用程序。

在 `Dockerfile` 的第二阶段，我们从 `builder` 中提取构建的应用程序，并在一个单独的容器中运行它。这消除了第一阶段构建阶段的所有不必要代码，并创建了一个更精简的最终应用程序容器，可以随时部署。

account/Dockerfile
```
FROM golang:alpine as builder

WORKDIR /go/src/app

# 在 dev 中获取 reflex 以进行实时重新加载
ENV GO111MODULE=on
RUN go get github.com/cespare/reflex

COPY go.mod .
COPY go.sum .

RUN go mod download

COPY . .

RUN go build -o ./run .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/

# 从 builder 中复制可执行文件
COPY --from=builder /go/src/app/run .

EXPOSE 8080
CMD ["./run"]
```

## 创建 docker-compose 文件
现在，我们将创建一个 `docker-compose.yml` 文件。只需在与该文件相同的文件夹中运行命令 `docker-compose up`，就可以使用该文件启动几个用于开发的 **docker 容器**(尽管在默认情况下，也可以使用命令行参数来定义文件路径)。我们将该文件保存在项目的根文件夹中。

在此文件中，我们创建了两个服务。

- reverse-proxy(反向代理) - [Traefik](https://doc.traefik.io/traefik/)
    - 该服务将运行 `Traefik docker` 镜像，我们将使用该反向代理将http请求路由到我们将创建的4个应用程序。
    - 我们用一组命令来配置 Traefik，这些命令对应于命令行参数。在本课程中，我们将不设置 TLS 证书，因此设置 `——api.insecure=true`。接下来的两个参数告诉 Traefik 在 Docker 容器中查找配置。不过，通常情况下，Traefik 会自动暴露带有一些默认值的 Docker 容器。我们将通过设置 `——providers.docker.exposedByDefault=false` 来禁用该选项。
    - 该服务的端口映射被配置为允许我们从 docker 主机(我们的机器)访问标准http端口(80)，还可以访问 Traefik 在端口(8080)上提供的一个很好的仪表板。

- account - `account`目录下的 go 应用程序
    - 首先，请注意该文件中的构建键（`build`）。我们告诉 `docker-compose` 我们想要创建一个在 `account` 文件夹中找到的容器。然而，还记得docker文件是如何使用“多阶段”构建的吗?对于开发，我们不需要运行最终的精益构建。因此，我们设置 `target: builder` 来告诉`docker-compose`只使用 Dockerfile 中标记为 `builder` 的第一个构建阶段来创建容器。
    - 我们添加了一些标签，我们就是这样设置 Docker 容器的，以便 Traefik 自动检测到。因为默认情况下我们不会公开所有容器，所以必须显式设置 `traefik.able=true`。下一个标签也非常重要。这将设置路由规则，告诉Traefik将任何http请求路由到 `malcorp.test/api/count` 到我们的 `account` 应用程序。
    - 最后，回想一下，我们在Dockerfile中安装了一个名为 `reflex` 的工具。该工具监视 `*.go` 文件(在本例中使用正则表达式)的任何更改，然后重新运行 main.go 文件。我们实际上使用的是 `go run./` 而不是 `go run main.go`，因为我们在根目录中将有多个 `*.go` 文件。

./docker-compose.yml
```
version: "3.8"
services:
  reverse-proxy:
    # 官方的 traefik v2 docker 镜像
    image: "traefik:v2.2"
    # 启用 web UI，并告诉Traefik侦听docker
    command:
      - "--api.insecure=true"
      - "--providers.docker"
      - "--providers.docker.exposedByDefault=false"
    ports:
      # HTTP 端口映射
      - "80:80"
      # traefik Web UI 端口映射(enable by --api.insecure=true)
      - "8080:8080"
    volumes:
      # 以便Traekit能够监听Docker事件
      - /var/run/docker.sock:/var/run/docker.sock
  account:
    build:
      context: ./account
      target: builder
    image: account
    expose:
      - "8080"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.account.rule=Host(`malcorp.test`) && PathPrefix(`/api/account`)"
    environment:
      - ENV=dev
    volumes:
      - "./account:/go/src/app"
    # 必须使用$$(双美元符号)，这样docker就不会尝试替换变量
    command: reflex -r "\.go$$" -s -- sh -c "go run ./"
```
## hosts 文件添加测试域名
为了使用 `malcorp.test` 域进行开发，我们必须将其添加到主机(hosts)文件中，以便当我们在浏览器、cURL、postman等中输入它时，它将解析到我们的本地计算机。你可以通过将下行添加到Mac/Linux上的`/etc/Hosts`或 `c：\WINDOWS\SYSTEM32\DRIVERS\ETC\HOSTS`(如果你使用的是 `Windows Subsystem for Linux`，也可以同时添加这两行代码)来实现这一点。在这两种情况下，你都需要使用管理权限(Mac/Linux上的 `sudo`)保存文件。
```
127.0.0.1       malcorp.test
```

## 运行应用
让我们试一试。在根文件夹中，运行 `docker-compose up`(如果需要重新构建容器，则可以运行`docker-compose --build`)。

现在，你可以打开浏览器并输入 http://malcorp.test/api/account， 您应该会收到 JSON 响应。
```
{"hello":"space peoples"}
```
现在尝试更改 `main.go` 中的响应。你应该可以看到服务器重新启动，刷新浏览器，并看到新的响应。(Windows 下不生效，因为 `cespare/reflex` 只支持linux 以及macos)

## 结尾

[下一篇](./02-creating-route-handlers-in-gin.md)，我们将向 gin 路由器添加路由，并介绍 `account` 应用程序的架构的一些细节。
